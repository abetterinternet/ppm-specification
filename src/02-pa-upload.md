# Upload

[TODO: Add an illustration of this sub-protocol.]

Uploading a report involves two requests to the leader. In the  *upload start
request*, the client discovers the protocol-specific parameters and the endpoint
URL of each helper. In the *upload finish request* uploads its report to the
leader.

## Upload Start

**Request.**
Let `[leader]` denote the URL of the leader's report ingestion endpoint. The
client sends a POST request to `[leader]/upload_start` with the following
message:

```
struct {
  PATask task;
  opaque id[16];
} PAUploadStartReq;
```

The first field, `task` corresponds to the PA task for which a report will be
generated. The second, `id` is a random, 32-byte string generated by the
client.

**Response.**
The leader responds to well-formed requests to `[leader]/upload_start` with
status 200 and the following message:

```
struct {
  Url helper_urls<0..2^16-1>;
  PAProto proto;
  select (PAUploadStartResp.proto) {
    case prio: PrioClientParam; // Section 3
    case hits: HitsClientParam; // Section 4
  }
} PAUploadStartResp;
```

The message includes the URL of each helper and any protocol specific parameters
the client needs to generate its report. The leader's response to malformed
requests is specified in [the "Error handling"
section](pa-error.md#common-abort-conditions).

## Upload Finish

For each URL `[helper]` in `PAClientParam.helper_urls`, the client sends a GET
request to `[helper]/key_config`. The helper responds with status 200 and an
`HPKEKeyConfig` message. Next, the client collects the set of helpers it will
upload shares to. It ignores a helper if:
* the client and helper failed to establish a secure, helper-authenticated
  channel;
* the GET request to the helper URL failed or didn't return a valid key config;
  or
* the key config specifies a KEM, KDF, or AEAD algorithm the client doesn't
  recognize.

If the set of supported helpers is empty, then the client aborts and alerts the
leader with "no supported helpers". Otherwise, for each supported helper the
client issues a POST request to `[leader]/upload_finish` with a payload
constructed as described below.

**Request.**
The client begins by [setting up an HPKE
context](https://www.ietf.org/archive/id/draft-irtf-cfrg-hpke-08.html#name-encryption-to-a-public-key,)
for the helper by running

```
helper_enc, context = SetupBaseS(pk, PAClientParam.task)
```

where `pk` is the KEM public key corresponding to `HPKEKeyConfig.public_key`.
The outputs are the encapsulated context `helper_enc` and the context `context`.

Next, the client encodes its measurements as an input for the PA protocol. It
then generates a validity proof for its input and uses `context` to split the
input and proof into a leader share and a helper share, where the latter is
encrypted by the HPKE context. Note that the details of each of these processing
steps --- encode, prove, split, and encrypt --- are specific to the PA protocol.

[OPEN QUESTION: Is it safe to generate the proof once, then secret-share between
each (leader, helper) pair? Probably not in general, but maybe for Prio?]

The payload of the POST request is structured as follows:

```
struct {
  PATask task;
  opaque id[16];              // Equal to PAUploadStartReq.id
  uint8 helper_key_config_id; // Euqal to HPKEKeyConfig.id
  Url helper_url;             // URL of helper endpoint
  PAHelperShare helper_share; // The helper's encrypted share
  PALeaderShare leader_share; // The leader's share
} PAUploadFinishReq;

struct {
  opaque enc<0..2^16-1>;     // Encapsulated HPKE context
  opaque payload<0..2^16-1>; // The encrypted share (may be empty)
} PAHelperShare;

opaque PALeaderShare<0..2^16-1>;
```

This message is called a *report*.

**Response.**
The leader responds to well-formed requests to `[leader]/upload_finish` with
status 200 and an empty payload. Malformed requests are handled as described in
[the "Error handling" section](pa-error.md#common-abort-conditions).
